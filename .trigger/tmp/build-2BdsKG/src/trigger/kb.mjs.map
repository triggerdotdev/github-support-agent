{
  "version": 3,
  "sources": ["../../../../../src/trigger/kb.ts"],
  "sourcesContent": ["import { schedules } from \"@trigger.dev/sdk\";\nimport { prisma } from \"@/lib/prisma\";\nimport { openai } from \"@ai-sdk/openai\";\nimport { generateObject } from \"ai\";\nimport { z } from \"zod\";\nimport { generateEmbedding } from \"@/lib/ai\";\nimport crypto from \"node:crypto\";\n\nexport const nightlyMaintenance = schedules.task({\n  id: \"nightly-maintenance\",\n  cron: \"0 0 * * *\", // Midnight\n  run: async () => {\n    const results = [];\n\n    // 1. Fetch all active KB entries\n    // We iterate through them to find clusters\n    // Note: querying all might be heavy for large DBs, would paginate in real app\n    const entries = await prisma.kbEntry.findMany({\n      where: { mergedIntoId: null },\n      select: { id: true, questionCanonical: true, answer: true, tags: true },\n    });\n\n    const processedIds = new Set<string>();\n    let mergedCount = 0;\n\n    for (const entry of entries) {\n      if (processedIds.has(entry.id)) continue;\n\n      // 2. Find similar entries (semantic duplicates)\n      const neighborsWithDistance = await prisma.$queryRaw<any[]>`\n        SELECT id, \"questionCanonical\", answer, tags, (embedding <-> (SELECT embedding FROM \"KbEntry\" WHERE id = ${entry.id})) as distance\n        FROM \"KbEntry\"\n        WHERE \"mergedIntoId\" IS NULL\n        AND id != ${entry.id}\n        ORDER BY distance ASC\n        LIMIT 5\n      `;\n\n      const candidates = neighborsWithDistance.filter(\n        (n: any) => n.distance < 0.15\n      ); // 0.15 threshold\n\n      if (candidates.length > 0) {\n        const cluster = [entry, ...candidates];\n\n        // Mark all as processed\n        cluster.forEach((c) => processedIds.add(c.id));\n\n        // 3. Merge logic via LLM\n        const prompt = `\nThe following Q&A pairs seem very similar. Please consolidate them into a single, high-quality canonical Q&A pair.\nIf they are not actually referring to the same issue, just return the best one as is.\n\nENTRIES:\n${cluster\n  .map((c) => `Q: ${c.questionCanonical}\\nA: ${c.answer}`)\n  .join(\"\\n---\\n\")}\n`;\n\n        const { object: merged } = await generateObject({\n          model: openai(\"gpt-4o\"),\n          schema: z.object({\n            question: z.string(),\n            answer: z.string(),\n            tags: z.array(z.string()),\n          }),\n          system: \"You are a knowledge base maintainer.\",\n          prompt,\n        });\n\n        const newEmbedding = await generateEmbedding(merged.question);\n        const embeddingString = `[${newEmbedding.join(\",\")}]`;\n\n        // 4. Create new merged entry\n        // Using raw query for vector support\n        const newId = crypto.randomUUID();\n        await prisma.$executeRaw`\n          INSERT INTO \"KbEntry\" (id, \"questionRaw\", \"questionCanonical\", answer, tags, embedding, \"createdAt\", \"updatedAt\")\n          VALUES (${newId}, 'Merged Entry', ${merged.question}, ${merged.answer}, ${merged.tags}, ${embeddingString}::vector, NOW(), NOW())\n        `;\n\n        // 5. Mark originals as merged\n        await prisma.kbEntry.updateMany({\n          where: { id: { in: cluster.map((c) => c.id) } },\n          data: { mergedIntoId: newId },\n        });\n\n        mergedCount++;\n      }\n    }\n    results.push({ mergedClusters: mergedCount });\n\n    return { results };\n  },\n});\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAMA,OAAO,YAAY;AAEZ,IAAM,qBAAqB,kBAAU,KAAK;AAAA,EAC/C,IAAI;AAAA,EACJ,MAAM;AAAA;AAAA,EACN,KAAK,mCAAY;AACf,UAAM,UAAU,CAAC;AAKjB,UAAM,UAAU,MAAM,OAAO,QAAQ,SAAS;AAAA,MAC5C,OAAO,EAAE,cAAc,KAAK;AAAA,MAC5B,QAAQ,EAAE,IAAI,MAAM,mBAAmB,MAAM,QAAQ,MAAM,MAAM,KAAK;AAAA,IACxE,CAAC;AAED,UAAM,eAAe,oBAAI,IAAY;AACrC,QAAI,cAAc;AAElB,eAAW,SAAS,SAAS;AAC3B,UAAI,aAAa,IAAI,MAAM,EAAE,EAAG;AAGhC,YAAM,wBAAwB,MAAM,OAAO;AAAA,mHACkE,MAAM,EAAE;AAAA;AAAA;AAAA,oBAGvG,MAAM,EAAE;AAAA;AAAA;AAAA;AAKtB,YAAM,aAAa,sBAAsB;AAAA,QACvC,CAAC,MAAW,EAAE,WAAW;AAAA,MAC3B;AAEA,UAAI,WAAW,SAAS,GAAG;AACzB,cAAM,UAAU,CAAC,OAAO,GAAG,UAAU;AAGrC,gBAAQ,QAAQ,CAAC,MAAM,aAAa,IAAI,EAAE,EAAE,CAAC;AAG7C,cAAM,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA,EAKrB,QACC,IAAI,CAAC,MAAM,MAAM,EAAE,iBAAiB;AAAA,KAAQ,EAAE,MAAM,EAAE,EACtD,KAAK,SAAS,CAAC;AAAA;AAGV,cAAM,EAAE,QAAQ,OAAO,IAAI,MAAM,eAAe;AAAA,UAC9C,OAAO,OAAO,QAAQ;AAAA,UACtB,QAAQ,iBAAE,OAAO;AAAA,YACf,UAAU,iBAAE,OAAO;AAAA,YACnB,QAAQ,iBAAE,OAAO;AAAA,YACjB,MAAM,iBAAE,MAAM,iBAAE,OAAO,CAAC;AAAA,UAC1B,CAAC;AAAA,UACD,QAAQ;AAAA,UACR;AAAA,QACF,CAAC;AAED,cAAM,eAAe,MAAM,kBAAkB,OAAO,QAAQ;AAC5D,cAAM,kBAAkB,IAAI,aAAa,KAAK,GAAG,CAAC;AAIlD,cAAM,QAAQ,OAAO,WAAW;AAChC,cAAM,OAAO;AAAA;AAAA,oBAED,KAAK,qBAAqB,OAAO,QAAQ,KAAK,OAAO,MAAM,KAAK,OAAO,IAAI,KAAK,eAAe;AAAA;AAI3G,cAAM,OAAO,QAAQ,WAAW;AAAA,UAC9B,OAAO,EAAE,IAAI,EAAE,IAAI,QAAQ,IAAI,CAAC,MAAM,EAAE,EAAE,EAAE,EAAE;AAAA,UAC9C,MAAM,EAAE,cAAc,MAAM;AAAA,QAC9B,CAAC;AAED;AAAA,MACF;AAAA,IACF;AACA,YAAQ,KAAK,EAAE,gBAAgB,YAAY,CAAC;AAE5C,WAAO,EAAE,QAAQ;AAAA,EACnB,GAlFK;AAmFP,CAAC;",
  "names": []
}
