{
  "version": 3,
  "sources": ["../../../../../src/trigger/issues.ts"],
  "sourcesContent": ["import { task } from \"@trigger.dev/sdk\";\nimport { prisma } from \"@/lib/prisma\";\nimport { openai } from \"@ai-sdk/openai\";\nimport { generateText, generateObject } from \"ai\";\nimport { z } from \"zod\";\nimport { generateEmbedding } from \"@/lib/ai\";\nimport { getIssueComments } from \"@/lib/github\";\n\n// Helper to perform RAG retrieval\nasync function retrieveContext(query: string) {\n  const embedding = await generateEmbedding(query);\n  const embeddingString = `[${embedding.join(\",\")}]`;\n\n  // Find relevant docs\n  const docs = await prisma.$queryRaw<any[]>`\n    SELECT id, content, heading, \"sourcePath\"\n    FROM \"DocChunk\"\n    ORDER BY embedding <-> ${embeddingString}::vector\n    LIMIT 5\n  `;\n\n  // Find relevant past Q&A\n  const kbs = await prisma.$queryRaw<any[]>`\n    SELECT id, \"questionCanonical\", answer, \"sourceUrl\"\n    FROM \"KbEntry\"\n    ORDER BY embedding <-> ${embeddingString}::vector\n    LIMIT 3\n  `;\n\n  return { docs, kbs };\n}\n\nexport const issueOpened = task({\n  id: \"issue-opened\",\n  run: async (payload: { issue: any }) => {\n    const { issue } = payload;\n\n    // 1. Persist Issue\n    // Upsert to handle edits if needed, though for now create is fine for \"opened\"\n    const dbIssue = await prisma.issue.create({\n      data: {\n        githubNumber: issue.number,\n        title: issue.title,\n        body: issue.body || \"\",\n        state: \"open\",\n        url: issue.html_url,\n        labels: issue.labels || [],\n        createdAt: new Date(),\n        messages: {\n          create: {\n            author: issue.user?.login || \"unknown\",\n            body: issue.body || \"\",\n            createdAt: new Date(),\n          },\n        },\n      },\n    });\n\n    // 2. Classify\n    const { object: classification } = await generateObject({\n      model: openai(\"gpt-4o\"),\n      schema: z.object({\n        type: z.enum([\"bug\", \"question\", \"feature\", \"other\"]),\n        reasoning: z.string(),\n      }),\n      system: \"Classify this issue based on the title and body.\",\n      prompt: `Title: ${issue.title}\\n\\nBody: ${issue.body}`,\n    });\n\n    await prisma.issue.update({\n      where: { id: dbIssue.id },\n      data: { classification: classification.type },\n    });\n\n    // 3. Retrieve\n    // We create a \"retrieval query\" from the issue\n    const retrievalQuery = `${issue.title} ${\n      classification.type\n    } ${issue.body?.slice(0, 200)}`;\n    const context = await retrieveContext(retrievalQuery);\n\n    // Log retrieval\n    await prisma.retrievalLog.create({\n      data: {\n        issueId: dbIssue.id,\n        query: retrievalQuery,\n        topDocIds: context.docs.map((d) => d.id),\n        topKbIds: context.kbs.map((k) => k.id),\n        rawScores: {}, // In a real app, we'd capture distances from the raw query\n      },\n    });\n\n    // 4. Draft\n    const prompt = `\nYou are an expert support engineer for this open source project.\nDraft a helpful, friendly reply to the user's issue.\n\nCONTEXT FROM DOCUMENTATION:\n${context.docs.map((d) => `[${d.heading}]: ${d.content}`).join(\"\\n\\n\")}\n\nCONTEXT FROM PAST ISSUES:\n${context.kbs\n  .map((k) => `Q: ${k.questionCanonical}\\nA: ${k.answer}`)\n  .join(\"\\n\\n\")}\n\nUSER ISSUE:\nTitle: ${issue.title}\nBody: ${issue.body}\n\nINSTRUCTIONS:\n- Be concise but thorough.\n- If the context provides a clear answer, use it.\n- If you are unsure, ask for clarifying information.\n- Reference the documentation if relevant.\n`;\n\n    const draft = await generateText({\n      model: openai(\"gpt-4o\"),\n      system: \"You are a helpful AI support assistant.\",\n      prompt: prompt,\n    });\n\n    // 5. Save Draft\n    await prisma.issueDraft.create({\n      data: {\n        issueId: dbIssue.id,\n        draftBody: draft.text,\n        modelName: \"gpt-4o\",\n        retrievalMeta: context,\n      },\n    });\n\n    return { success: true, draftId: dbIssue.id };\n  },\n});\n\nexport const issueClosed = task({\n  id: \"issue-closed\",\n  run: async (payload: { issue: any }) => {\n    const { issue } = payload;\n    const owner = process.env.GITHUB_OWNER;\n    const repo = process.env.GITHUB_REPO;\n\n    if (!owner || !repo)\n      throw new Error(\"GITHUB_OWNER and GITHUB_REPO env vars must be set\");\n\n    // Try to find existing issue in DB\n    // Note: we can't query by projectId anymore, so we assume single repo in DB\n    // But if we had multiple issues with same number (recreated DB?), this might be ambiguous.\n    // In single-tenant app, githubNumber is unique per repo effectively.\n    const dbIssue = await prisma.issue.findFirst({\n      where: { githubNumber: issue.number },\n    });\n\n    // Fetch full thread\n    const comments = await getIssueComments(owner, repo, issue.number);\n    const fullThread = `\nTitle: ${issue.title}\nBody: ${issue.body}\n\nComments:\n${comments.map((c: any) => `${c.user?.login}: ${c.body}`).join(\"\\n---\\n\")}\n        `;\n\n    // Summarize into Q&A\n    const { object: summary } = await generateObject({\n      model: openai(\"gpt-4o\"),\n      schema: z.object({\n        question: z.string().describe(\"Canonical question phrasing\"),\n        answer: z\n          .string()\n          .describe(\"Consolidated answer including code snippets if any\"),\n        tags: z.array(z.string()),\n      }),\n      system:\n        \"Summarize this resolved GitHub issue into a useful Q&A pair for a knowledge base.\",\n      prompt: fullThread,\n    });\n\n    // Generate embedding for the canonical question\n    const embedding = await generateEmbedding(summary.question);\n    const embeddingString = `[${embedding.join(\",\")}]`;\n\n    // Save to KB\n    await prisma.$executeRaw`\n            INSERT INTO \"KbEntry\" (id, \"issueId\", \"questionRaw\", \"questionCanonical\", answer, tags, \"sourceUrl\", embedding, \"createdAt\", \"updatedAt\")\n            VALUES (gen_random_uuid(), ${dbIssue?.id || null}, ${\n      issue.title\n    }, ${summary.question}, ${summary.answer}, ${summary.tags}, ${\n      issue.html_url\n    }, ${embeddingString}::vector, NOW(), NOW())\n        `;\n  },\n});\n"],
  "mappings": "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",
  "names": []
}
